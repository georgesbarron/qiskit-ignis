# -*- coding: utf-8 -*-

# This code is part of Qiskit.
#
# (C) Copyright IBM 2019, 2020.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.
"""
Full A-matrix measurement migitation generator.
"""

from typing import Optional, Tuple, List

from qiskit import QuantumCircuit, transpile
from qiskit.exceptions import QiskitError
from qiskit.providers import BaseBackend


class MeasMitigatorGenerator:
    """Measurement error mitigator calibration generator."""

    # pylint: disable=arguments-differ
    def __init__(self,
                 num_qubits: int,
                 method: str = 'CTMP',
                 labels: Optional[List[str]] = None):
        """Initialize measurement mitigator calibration generator."""
        self._num_qubits = num_qubits
        self._circuits = []
        self._metadata = []
        if labels is None:
            labels = self._method_labels(method)
        for label in labels:
            self._metadata.append({
                'experiment': 'meas_mit',
                'cal': label,
            })
            self._circuits.append(self._calibration_circuit(num_qubits, label))

    def _method_labels(self, method):
        """Generate labels for initilizing via a standard method."""

        if method == 'tensored':
            return [self._num_qubits * '0', self._num_qubits * '1']

        if method in ['CTMP', 'ctmp']:
            labels = [self._num_qubits * '0', self._num_qubits * '1']
            for i in range(self._num_qubits):
                labels.append(((self._num_qubits - i - 1) * '0') + '1' +
                              (i * '0'))
            return labels

        if method == 'complete':
            labels = []
            for i in range(2**self._num_qubits):
                bits = bin(i)[2:]
                label = (self._num_qubits - len(bits)) * '0' + bits
                labels.append(label)
            return labels

        raise QiskitError("Unrecognized method {}".format(method))

    def run(self,
            qubits: Optional[List[int]] = None,
            backend: Optional[BaseBackend] = None
            ) -> Tuple[List[QuantumCircuit], List[dict], dict]:
        """Return experiment payload data.
​
        Args:
            qubits: Opiontal, apply the N-qubit calibration circuits to these device qubits.
            backend: Optional, transpile circuits for a specific backend.
​
        Returns:
            tuple: (circuits, metadata, run_config)
​
        Circuits is a list of circuits for the experiments, metadata is a list of metadata
        for the experiment that is required by the fitter to interpreting results, run_config
        is a dictionary of parameters for configuring a backend (or running the experiment)
        """
        circuits = self.circuits(qubits=qubits,
                                 backend=backend)
        metadata = self.metadata(qubits=qubits,
                                 backend=backend)
        run_config = self.run_config(qubits=qubits,
                                     backend=backend)
        return circuits, metadata, run_config

    def circuits(self,
                 qubits: Optional[List[int]] = None,
                 backend: Optional[BaseBackend] = None) -> List[QuantumCircuit]:
        """Return only the circuits generated by the run command.
​
        Args:
            qubits: Opiontal, apply the N-qubit calibration circuits to these device qubits.
            backend: Optional, transpile circuits for a specific backend.
​
        Returns:
            Generated circuits.
        """
        circuits = self._circuits
        if qubits or backend:
            if backend is None:
                # We need to provide a dummy coupling map for initial_layout
                # to work. So we apply a 1D layout here
                coupling_map = [[i - 1, i]
                                for i in range(1, max(qubits))]
            else:
                coupling_map = None
            circuits = transpile(circuits,
                                 backend=backend,
                                 coupling_map=coupling_map,
                                 initial_layout=qubits)
        return circuits

    def metadata(self,
                 qubits: Optional[List[int]] = None,
                 backend: Optional[BaseBackend] = None) -> List[dict]:
        """Generate a list of metadata.
​
        Args:
            qubits: Opiontal, apply the N-qubit calibration circuits to these device qubits.
            backend: Optional, transpile circuits for a specific backend.
​
        Returns:
            Metdata dictionaries.
        """
        if qubits is None and backend is None:
            return self._metadata
        new_meta = []
        for meta in self._metadata:
            tmp = meta.copy()
            if qubits:
                tmp['qubits'] = qubits
            if backend:
                tmp['backend'] = backend.name
            new_meta.append(tmp)
        return new_meta

    def run_config(self,
                   qubits: Optional[List[int]] = None,
                   backend: Optional[BaseBackend] = None) -> dict:
        """Generate any backend config needed for execution.

        Args:
            qubits: Opiontal, apply the N-qubit calibration circuits to these device qubits.
            backend: Optional, transpile circuits for a specific backend.
​
        Returns:
            Runconfig
        """
        # pylint: disable=unused-argument
        return {}

    @staticmethod
    def _calibration_circuit(num_qubits: int, label: str) -> QuantumCircuit:
        """Return a calibration circuit.

        This is an N-qubit circuit where N is the length of the label.
        The circuit consists of X-gates on qubits with label bits equal to 1,
        and measurements of all qubits.
        """
        circ = QuantumCircuit(num_qubits, name='meas_mit_cal_' + label)
        for i, val in enumerate(reversed(label)):
            if val == '1':
                circ.x(i)
        circ.measure_all()
        return circ
